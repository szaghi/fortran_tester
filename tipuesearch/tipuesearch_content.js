var tipuesearch = {"pages":[{"text":"fortran_tester Fortran tester tester is a Fortran module to test Fortran programs. It provides routines to\ncheck equality or closeness between variables and counting the errors. A minimal example: program test use tester implicit none type ( tester_t ) :: my_tester call my_tester % init () call my_tester % assert_equal ( 1 , 2 , fail = . true .) call my_tester % print () end program test If none of the tests fail, the print method displays the message fortran_tester: all tests succeeded .\nElse, the program will exit with a nonzero error code, making it suitable for\nuse as an automated test. Author: Pierre de Buyl License: BSD Contributors: Peter Colberg Developer Info Pierre de Buyl","tags":"","loc":"index.html","title":" fortran_tester "},{"text":"Files Dependent On This One sourcefile~~tester.f90~~AfferentGraph sourcefile~tester.f90 tester.f90 sourcefile~test_tester_1.f90 test_tester_1.f90 sourcefile~tester.f90->sourcefile~test_tester_1.f90 sourcefile~test_tester_4.f90 test_tester_4.f90 sourcefile~tester.f90->sourcefile~test_tester_4.f90 sourcefile~test_tester_2.f90 test_tester_2.f90 sourcefile~tester.f90->sourcefile~test_tester_2.f90 sourcefile~test_tester_3.f90 test_tester_3.f90 sourcefile~tester.f90->sourcefile~test_tester_3.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules tester Source Code tester.f90 Source Code ! This file is part of fortran_tester ! Copyright 2015 Pierre de Buyl and Peter Colberg !           2016 Pierre de Buyl ! License: BSD module tester use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 implicit none private public :: tester_t type :: tester_t !< The main **tester** class. integer ( int32 ) :: n_errors = 0_int32 !< Number of errors. integer ( int32 ) :: n_tests = 0_int32 !< Number of tests. real ( real32 ) :: tolerance32 = 2._real32 * epsilon ( 1._real32 ) !< Real tolerance, 32 bits. real ( real64 ) :: tolerance64 = 2._real64 * epsilon ( 1._real64 ) !< Real tolerance, 64 bits. contains procedure :: init !< Initialize the tester. procedure :: print !< Print tests results. generic , public :: assert_equal => & assert_equal_i8 , & assert_equal_i16 , & assert_equal_i32 , & assert_equal_i64 , & assert_equal_r32 , & assert_equal_r64 , & assert_equal_l , & assert_equal_i8_1 , & assert_equal_i16_1 , & assert_equal_i32_1 , & assert_equal_i64_1 , & assert_equal_r32_1 , & assert_equal_r64_1 , & assert_equal_l_1 !< Check if two results (integer, real or logical) are equal. procedure , private :: assert_equal_i8 !< Check if two integers (8  bits) are equal. procedure , private :: assert_equal_i16 !< Check if two integers (16 bits) are equal. procedure , private :: assert_equal_i32 !< Check if two integers (32 bits) are equal. procedure , private :: assert_equal_i64 !< Check if two integers (64 bits) are equal. procedure , private :: assert_equal_r32 !< Check if two reals (32 bits) are equal. procedure , private :: assert_equal_r64 !< Check if two reals (64 bits) are equal. procedure , private :: assert_equal_l !< Check if two logicals are equal. procedure , private :: assert_equal_i8_1 !< Check if two integer (8  bits) arrays (rank 1) are equal. procedure , private :: assert_equal_i16_1 !< Check if two integer (16 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_i32_1 !< Check if two integer (32 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_i64_1 !< Check if two integer (64 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_r32_1 !< Check if two real (32 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_r64_1 !< Check if two real (64 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_l_1 !< Check if two logical arrays (rank 1) are equal. generic , public :: assert_positive => & assert_positive_i8 , & assert_positive_i16 , & assert_positive_i32 , & assert_positive_i64 , & assert_positive_r32 , & assert_positive_r64 , & assert_positive_i8_1 , & assert_positive_i16_1 , & assert_positive_i32_1 , & assert_positive_i64_1 , & assert_positive_r32_1 , & assert_positive_r64_1 !< Check if a number (integer or real) is positive. procedure , private :: assert_positive_i8 !< Check if a integer (8  bits) is positive. procedure , private :: assert_positive_i16 !< Check if a integer (16 bits) is positive. procedure , private :: assert_positive_i32 !< Check if a integer (32 bits) is positive. procedure , private :: assert_positive_i64 !< Check if a integer (64 bits) is positive. procedure , private :: assert_positive_r32 !< Check if a real (32 bits) is positive. procedure , private :: assert_positive_r64 !< Check if a real (64 bits) is positive. procedure , private :: assert_positive_i8_1 !< Check if a integer (8  bits) array (rank 1) is positive. procedure , private :: assert_positive_i16_1 !< Check if a integer (16 bits) array (rank 1) is positive. procedure , private :: assert_positive_i32_1 !< Check if a integer (32 bits) array (rank 1) is positive. procedure , private :: assert_positive_i64_1 !< Check if a integer (64 bits) array (rank 1) is positive. procedure , private :: assert_positive_r32_1 !< Check if a real (32 bits) array (rank 1) is positive. procedure , private :: assert_positive_r64_1 !< Check if a real (64 bits) array (rank 1) is positive. generic , public :: assert_close => & assert_close_r32 , & assert_close_r64 , & assert_close_r32_1 , & assert_close_r64_1 !< Check if two reals are close with respect a tolerance. procedure , private :: assert_close_r32 !< Check if two reals (32 bits) are close with respect a tolerance. procedure , private :: assert_close_r64 !< Check if two reals (64 bits) are close with respect a tolerance. procedure , private :: assert_close_r32_1 !< Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. procedure , private :: assert_close_r64_1 !< Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. end type tester_t contains subroutine init ( this , tolerance32 , tolerance64 ) !< Initialize the tester. class ( tester_t ), intent ( out ) :: this !< The tester. real ( real32 ), intent ( in ), optional :: tolerance32 !< Real tolerance, 32 bits. real ( real64 ), intent ( in ), optional :: tolerance64 !< Real tolerance, 64 bits. this % n_errors = 0 this % n_tests = 0 if ( present ( tolerance64 )) then this % tolerance64 = tolerance64 else this % tolerance64 = 2._real64 * epsilon ( 1._real64 ) end if if ( present ( tolerance32 )) then this % tolerance32 = tolerance32 else this % tolerance32 = 2._real32 * epsilon ( 1._real32 ) end if end subroutine init subroutine print ( this , errorstop ) !< Print tests results. class ( tester_t ), intent ( in ) :: this !< The tester. logical , intent ( in ), optional :: errorstop !< Flag to activate error stop if one test fails. logical :: do_errorstop if ( present ( errorstop )) then do_errorstop = errorstop else do_errorstop = . true . end if write ( * , * ) 'fortran_tester:' , this % n_errors , ' error(s) for' , this % n_tests , 'test(s)' if ( this % n_errors == 0 ) then write ( * , * ) 'fortran_tester: all tests succeeded' else if ( do_errorstop ) then error stop 'fortran_tester: tests failed' else write ( * , * ) 'fortran_tester: tests failed' end if end if end subroutine print subroutine assert_equal_i8 ( this , i1 , i2 , fail ) !< Check if two integers (8 bits) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int8 ), intent ( in ) :: i1 , i2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( i1 . ne . i2 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_i8 subroutine assert_equal_i16 ( this , i1 , i2 , fail ) !< Check if two integers (16 bits) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int16 ), intent ( in ) :: i1 , i2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( i1 . ne . i2 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_i16 subroutine assert_equal_i32 ( this , i1 , i2 , fail ) !< Check if two integers (32 bits) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int32 ), intent ( in ) :: i1 , i2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( i1 . ne . i2 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_i32 subroutine assert_equal_i64 ( this , i1 , i2 , fail ) !< Check if two integers (64 bits) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int64 ), intent ( in ) :: i1 , i2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( i1 . ne . i2 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_i64 subroutine assert_equal_r32 ( this , r1 , r2 , fail ) !< Check if two reals (32 bits) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), intent ( in ) :: r1 , r2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( r1 . ne . r2 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_r32 subroutine assert_equal_r64 ( this , r1 , r2 , fail ) !< Check if two reals (64 bits) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), intent ( in ) :: r1 , r2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( r1 . ne . r2 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_r64 subroutine assert_equal_l ( this , l1 , l2 , fail ) !< Check if two logicals are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. logical , intent ( in ) :: l1 , l2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( l1 . neqv . l2 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_l subroutine assert_equal_i8_1 ( this , i1 , i2 , fail ) !< Check if two integer (8 bits) arrays (rank 1) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int8 ), dimension (:), intent ( in ) :: i1 , i2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( size ( i1 ) . ne . size ( i2 ) ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if else if ( maxval ( abs ( i1 - i2 )) > 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end if end subroutine assert_equal_i8_1 subroutine assert_equal_i16_1 ( this , i1 , i2 , fail ) !< Check if two integer (16 bits) arrays (rank 1) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int16 ), dimension (:), intent ( in ) :: i1 , i2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( size ( i1 ) . ne . size ( i2 ) ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if else if ( maxval ( abs ( i1 - i2 )) > 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end if end subroutine assert_equal_i16_1 subroutine assert_equal_i32_1 ( this , i1 , i2 , fail ) !< Check if two integer (32 bits) arrays (rank 1) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int32 ), dimension (:), intent ( in ) :: i1 , i2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( size ( i1 ) . ne . size ( i2 ) ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if else if ( maxval ( abs ( i1 - i2 )) > 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end if end subroutine assert_equal_i32_1 subroutine assert_equal_i64_1 ( this , i1 , i2 , fail ) !< Check if two integer (64 bits) arrays (rank 1) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int64 ), dimension (:), intent ( in ) :: i1 , i2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( size ( i1 ) . ne . size ( i2 ) ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if else if ( maxval ( abs ( i1 - i2 )) > 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end if end subroutine assert_equal_i64_1 subroutine assert_equal_r32_1 ( this , r1 , r2 , fail ) !< Check if two real (32 bits) arrays (rank 1) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), dimension (:), intent ( in ) :: r1 , r2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( size ( r1 ) . ne . size ( r2 ) ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if else if ( maxval ( abs ( r1 - r2 )) > 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end if end subroutine assert_equal_r32_1 subroutine assert_equal_r64_1 ( this , r1 , r2 , fail ) !< Check if two real (64 bits) arrays (rank 1) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), dimension (:), intent ( in ) :: r1 , r2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( size ( r1 ) . ne . size ( r2 ) ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if else if ( maxval ( abs ( r1 - r2 )) > 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end if end subroutine assert_equal_r64_1 subroutine assert_equal_l_1 ( this , l1 , l2 , fail ) !< Check if two logical arrays (rank 1) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. logical , intent ( in ), dimension (:) :: l1 , l2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. integer :: k this % n_tests = this % n_tests + 1 if ( size ( l1 ) . ne . size ( l2 ) ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if else do k = 1 , size ( l1 ) if ( l1 ( k ) . neqv . l2 ( k )) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if exit end if end do end if end subroutine assert_equal_l_1 subroutine assert_positive_i8 ( this , i , fail ) !< Check if a integer (32 bits) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int8 ), intent ( in ) :: i !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( i < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_i8 subroutine assert_positive_i16 ( this , i , fail ) !< Check if a integer (16 bits) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int16 ), intent ( in ) :: i !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( i < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_i16 subroutine assert_positive_i32 ( this , i , fail ) !< Check if a integer (32 bits) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int32 ), intent ( in ) :: i !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( i < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_i32 subroutine assert_positive_i64 ( this , i , fail ) !< Check if a integer (32 bits) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int64 ), intent ( in ) :: i !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( i < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_i64 subroutine assert_positive_r32 ( this , r , fail ) !< Check if a real (32 bits) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), intent ( in ) :: r !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( r < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_r32 subroutine assert_positive_r64 ( this , r , fail ) !< Check if a real (64 bits) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), intent ( in ) :: r !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( r < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_r64 subroutine assert_positive_i8_1 ( this , i , fail ) !< Check if a integer (8 bits) array (rank 1) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int8 ), dimension (:), intent ( in ) :: i !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( minval ( i ) < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_i8_1 subroutine assert_positive_i16_1 ( this , i , fail ) !< Check if a integer (16 bits) array (rank 1) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int16 ), dimension (:), intent ( in ) :: i !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( minval ( i ) < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_i16_1 subroutine assert_positive_i32_1 ( this , i , fail ) !< Check if a integer (32 bits) array (rank 1) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int32 ), dimension (:), intent ( in ) :: i !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( minval ( i ) < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_i32_1 subroutine assert_positive_i64_1 ( this , i , fail ) !< Check if a integer (64 bits) array (rank 1) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int64 ), dimension (:), intent ( in ) :: i !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( minval ( i ) < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_i64_1 subroutine assert_positive_r32_1 ( this , r , fail ) !< Check if a real (32 bits) array (rank 1) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), dimension (:), intent ( in ) :: r !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( minval ( r ) < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_r32_1 subroutine assert_positive_r64_1 ( this , r , fail ) !< Check if a real (64 bits) array (rank 1) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), dimension (:), intent ( in ) :: r !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( minval ( r ) < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_r64_1 subroutine assert_close_r32 ( this , r1 , r2 , fail ) !< Check if two reals (32 bits) are close with respect a tolerance. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), intent ( in ) :: r1 , r2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( abs ( r1 - r2 ) > this % tolerance32 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_close_r32 subroutine assert_close_r64 ( this , r1 , r2 , fail ) !< Check if two reals (64 bits) are close with respect a tolerance. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), intent ( in ) :: r1 , r2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( abs ( r1 - r2 ) > this % tolerance64 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_close_r64 subroutine assert_close_r32_1 ( this , r1 , r2 , fail ) !< Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), intent ( in ), dimension (:) :: r1 , r2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( size ( r1 ) . ne . size ( r2 ) ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if else if ( maxval ( abs ( r1 - r2 )) > this % tolerance64 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end if end subroutine assert_close_r32_1 subroutine assert_close_r64_1 ( this , r1 , r2 , fail ) !< Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), intent ( in ), dimension (:) :: r1 , r2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( size ( r1 ) . ne . size ( r2 ) ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if else if ( maxval ( abs ( r1 - r2 )) > this % tolerance64 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end if end subroutine assert_close_r64_1 end module tester","tags":"","loc":"sourcefile/tester.f90.html","title":"tester.f90 – fortran_tester"},{"text":"This File Depends On sourcefile~~test_tester_1.f90~~EfferentGraph sourcefile~test_tester_1.f90 test_tester_1.f90 sourcefile~tester.f90 tester.f90 sourcefile~tester.f90->sourcefile~test_tester_1.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_mt Source Code test_tester_1.f90 Source Code ! This file is part of fortran_tester ! Copyright 2015 Pierre de Buyl ! License: BSD program test_mt use tester implicit none type ( tester_t ) :: test call test % init () call test % assert_equal ( 1 , 2 , fail = . true .) call test % assert_equal ( - 121 , - 11 ** 2 ) call test % assert_equal ([ 1 , - 10 , 1899010 ], [ 1 , - 10 , 1899010 ]) call test % assert_equal (. true ., 2 > 1 ) call test % assert_close ( 1. d0 , ( 1. d0 + 1. d - 16 )) call test % assert_close ( 1. d0 , ( 1. d0 + 1. d - 15 ), fail = . true .) call test % assert_close ( 1. , ( 1. + 1.e-7 )) call test % assert_close ( 1. , ( 1. + 1.e-6 ), fail = . true .) call test % assert_close ([ 1. d0 , 2. d0 , 3. d0 ], [ 1. d0 + 1. d - 15 , 2. d0 , 3. d0 ], fail = . true .) call test % assert_close ([ 1. d0 , 2. d0 ], [ 1. d0 , 2. d0 , 3. d0 ], fail = . true .) call test % assert_close ([ 1. d0 , 2. d0 ], [ 1. d0 , 2. d0 ]) call test % print () end program test_mt","tags":"","loc":"sourcefile/test_tester_1.f90.html","title":"test_tester_1.f90 – fortran_tester"},{"text":"This File Depends On sourcefile~~test_tester_2.f90~~EfferentGraph sourcefile~test_tester_2.f90 test_tester_2.f90 sourcefile~tester.f90 tester.f90 sourcefile~tester.f90->sourcefile~test_tester_2.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_mt Source Code test_tester_2.f90 Source Code ! This file is part of fortran_tester ! Copyright 2015 Pierre de Buyl ! License: BSD program test_mt use tester implicit none type ( tester_t ) :: test call test % init () call test % assert_equal ( 1 , 2 ) call test % print () end program test_mt","tags":"","loc":"sourcefile/test_tester_2.f90.html","title":"test_tester_2.f90 – fortran_tester"},{"text":"This File Depends On sourcefile~~test_tester_3.f90~~EfferentGraph sourcefile~test_tester_3.f90 test_tester_3.f90 sourcefile~tester.f90 tester.f90 sourcefile~tester.f90->sourcefile~test_tester_3.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_mt Source Code test_tester_3.f90 Source Code ! This file is part of fortran_tester ! Copyright 2015 Pierre de Buyl ! License: BSD program test_mt use tester implicit none type ( tester_t ) :: test call test % init () call test % assert_equal ([. false ., . true .], [ 1 > 2 , 2 > 1 ]) call test % print () end program test_mt","tags":"","loc":"sourcefile/test_tester_3.f90.html","title":"test_tester_3.f90 – fortran_tester"},{"text":"This File Depends On sourcefile~~test_tester_4.f90~~EfferentGraph sourcefile~test_tester_4.f90 test_tester_4.f90 sourcefile~tester.f90 tester.f90 sourcefile~tester.f90->sourcefile~test_tester_4.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_mt Source Code test_tester_4.f90 Source Code ! This file is part of fortran_tester ! Copyright 2015 Pierre de Buyl ! License: BSD program test_mt use tester implicit none type ( tester_t ) :: test call test % init () call test % assert_equal (. true ., 1 > 2 ) call test % print () end program test_mt","tags":"","loc":"sourcefile/test_tester_4.f90.html","title":"test_tester_4.f90 – fortran_tester"},{"text":"type, public :: tester_t The main tester class. Variables n_errors n_tests tolerance32 tolerance64 Type-Bound Procedures init print assert_equal assert_equal_i8 assert_equal_i16 assert_equal_i32 assert_equal_i64 assert_equal_r32 assert_equal_r64 assert_equal_l assert_equal_i8_1 assert_equal_i16_1 assert_equal_i32_1 assert_equal_i64_1 assert_equal_r32_1 assert_equal_r64_1 assert_equal_l_1 assert_positive assert_positive_i8 assert_positive_i16 assert_positive_i32 assert_positive_i64 assert_positive_r32 assert_positive_r64 assert_positive_i8_1 assert_positive_i16_1 assert_positive_i32_1 assert_positive_i64_1 assert_positive_r32_1 assert_positive_r64_1 assert_close assert_close_r32 assert_close_r64 assert_close_r32_1 assert_close_r64_1 Source Code tester_t Components Type Visibility Attributes Name Initial integer(kind=int32), public :: n_errors = 0_int32 Number of errors. integer(kind=int32), public :: n_tests = 0_int32 Number of tests. real(kind=real32), public :: tolerance32 = 2._real32*epsilon(1._real32) Real tolerance, 32 bits. real(kind=real64), public :: tolerance64 = 2._real64*epsilon(1._real64) Real tolerance, 64 bits. Type-Bound Procedures procedure, public :: init Initialize the tester. private subroutine init (this, tolerance32, tolerance64) Initialize the tester. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(out) :: this The tester. real(kind=real32), intent(in), optional :: tolerance32 Real tolerance, 32 bits. real(kind=real64), intent(in), optional :: tolerance64 Real tolerance, 64 bits. procedure, public :: print Print tests results. private subroutine print (this, errorstop) Print tests results. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(in) :: this The tester. logical, intent(in), optional :: errorstop Flag to activate error stop if one test fails. generic, public :: assert_equal => assert_equal_i8 , assert_equal_i16 , assert_equal_i32 , assert_equal_i64 , assert_equal_r32 , assert_equal_r64 , assert_equal_l , assert_equal_i8_1 , assert_equal_i16_1 , assert_equal_i32_1 , assert_equal_i64_1 , assert_equal_r32_1 , assert_equal_r64_1 , assert_equal_l_1 Check if two results (integer, real or logical) are equal. private subroutine assert_equal_i8 (this, i1, i2, fail) Check if two integers (8 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in) :: i1 Results to be compared. integer(kind=int8), intent(in) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_i16 (this, i1, i2, fail) Check if two integers (16 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in) :: i1 Results to be compared. integer(kind=int16), intent(in) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_i32 (this, i1, i2, fail) Check if two integers (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in) :: i1 Results to be compared. integer(kind=int32), intent(in) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_i64 (this, i1, i2, fail) Check if two integers (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in) :: i1 Results to be compared. integer(kind=int64), intent(in) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_r32 (this, r1, r2, fail) Check if two reals (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r1 Results to be compared. real(kind=real32), intent(in) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_r64 (this, r1, r2, fail) Check if two reals (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r1 Results to be compared. real(kind=real64), intent(in) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_l (this, l1, l2, fail) Check if two logicals are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. logical, intent(in) :: l1 Results to be compared. logical, intent(in) :: l2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_i8_1 (this, i1, i2, fail) Check if two integer (8 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in), dimension(:) :: i1 Results to be compared. integer(kind=int8), intent(in), dimension(:) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_i16_1 (this, i1, i2, fail) Check if two integer (16 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in), dimension(:) :: i1 Results to be compared. integer(kind=int16), intent(in), dimension(:) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_i32_1 (this, i1, i2, fail) Check if two integer (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in), dimension(:) :: i1 Results to be compared. integer(kind=int32), intent(in), dimension(:) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_i64_1 (this, i1, i2, fail) Check if two integer (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in), dimension(:) :: i1 Results to be compared. integer(kind=int64), intent(in), dimension(:) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_r32_1 (this, r1, r2, fail) Check if two real (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r1 Results to be compared. real(kind=real32), intent(in), dimension(:) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_r64_1 (this, r1, r2, fail) Check if two real (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r1 Results to be compared. real(kind=real64), intent(in), dimension(:) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_l_1 (this, l1, l2, fail) Check if two logical arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. logical, intent(in), dimension(:) :: l1 Results to be compared. logical, intent(in), dimension(:) :: l2 Results to be compared. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_equal_i8 Check if two integers (8  bits) are equal. private subroutine assert_equal_i8 (this, i1, i2, fail) Check if two integers (8 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in) :: i1 Results to be compared. integer(kind=int8), intent(in) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_equal_i16 Check if two integers (16 bits) are equal. private subroutine assert_equal_i16 (this, i1, i2, fail) Check if two integers (16 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in) :: i1 Results to be compared. integer(kind=int16), intent(in) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_equal_i32 Check if two integers (32 bits) are equal. private subroutine assert_equal_i32 (this, i1, i2, fail) Check if two integers (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in) :: i1 Results to be compared. integer(kind=int32), intent(in) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_equal_i64 Check if two integers (64 bits) are equal. private subroutine assert_equal_i64 (this, i1, i2, fail) Check if two integers (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in) :: i1 Results to be compared. integer(kind=int64), intent(in) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_equal_r32 Check if two reals (32 bits) are equal. private subroutine assert_equal_r32 (this, r1, r2, fail) Check if two reals (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r1 Results to be compared. real(kind=real32), intent(in) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_equal_r64 Check if two reals (64 bits) are equal. private subroutine assert_equal_r64 (this, r1, r2, fail) Check if two reals (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r1 Results to be compared. real(kind=real64), intent(in) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_equal_l Check if two logicals are equal. private subroutine assert_equal_l (this, l1, l2, fail) Check if two logicals are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. logical, intent(in) :: l1 Results to be compared. logical, intent(in) :: l2 Results to be compared. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_equal_i8_1 Check if two integer (8  bits) arrays (rank 1) are equal. private subroutine assert_equal_i8_1 (this, i1, i2, fail) Check if two integer (8 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in), dimension(:) :: i1 Results to be compared. integer(kind=int8), intent(in), dimension(:) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_equal_i16_1 Check if two integer (16 bits) arrays (rank 1) are equal. private subroutine assert_equal_i16_1 (this, i1, i2, fail) Check if two integer (16 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in), dimension(:) :: i1 Results to be compared. integer(kind=int16), intent(in), dimension(:) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_equal_i32_1 Check if two integer (32 bits) arrays (rank 1) are equal. private subroutine assert_equal_i32_1 (this, i1, i2, fail) Check if two integer (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in), dimension(:) :: i1 Results to be compared. integer(kind=int32), intent(in), dimension(:) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_equal_i64_1 Check if two integer (64 bits) arrays (rank 1) are equal. private subroutine assert_equal_i64_1 (this, i1, i2, fail) Check if two integer (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in), dimension(:) :: i1 Results to be compared. integer(kind=int64), intent(in), dimension(:) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_equal_r32_1 Check if two real (32 bits) arrays (rank 1) are equal. private subroutine assert_equal_r32_1 (this, r1, r2, fail) Check if two real (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r1 Results to be compared. real(kind=real32), intent(in), dimension(:) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_equal_r64_1 Check if two real (64 bits) arrays (rank 1) are equal. private subroutine assert_equal_r64_1 (this, r1, r2, fail) Check if two real (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r1 Results to be compared. real(kind=real64), intent(in), dimension(:) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_equal_l_1 Check if two logical arrays (rank 1) are equal. private subroutine assert_equal_l_1 (this, l1, l2, fail) Check if two logical arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. logical, intent(in), dimension(:) :: l1 Results to be compared. logical, intent(in), dimension(:) :: l2 Results to be compared. logical, intent(in), optional :: fail Fail flag. generic, public :: assert_positive => assert_positive_i8 , assert_positive_i16 , assert_positive_i32 , assert_positive_i64 , assert_positive_r32 , assert_positive_r64 , assert_positive_i8_1 , assert_positive_i16_1 , assert_positive_i32_1 , assert_positive_i64_1 , assert_positive_r32_1 , assert_positive_r64_1 Check if a number (integer or real) is positive. private subroutine assert_positive_i8 (this, i, fail) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_i16 (this, i, fail) Check if a integer (16 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_i32 (this, i, fail) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_i64 (this, i, fail) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_r32 (this, r, fail) Check if a real (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_r64 (this, r, fail) Check if a real (64 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_i8_1 (this, i, fail) Check if a integer (8 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in), dimension(:) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_i16_1 (this, i, fail) Check if a integer (16 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in), dimension(:) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_i32_1 (this, i, fail) Check if a integer (32 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in), dimension(:) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_i64_1 (this, i, fail) Check if a integer (64 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in), dimension(:) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_r32_1 (this, r, fail) Check if a real (32 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_r64_1 (this, r, fail) Check if a real (64 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r Result to be checked. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_positive_i8 Check if a integer (8  bits) is positive. private subroutine assert_positive_i8 (this, i, fail) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_positive_i16 Check if a integer (16 bits) is positive. private subroutine assert_positive_i16 (this, i, fail) Check if a integer (16 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_positive_i32 Check if a integer (32 bits) is positive. private subroutine assert_positive_i32 (this, i, fail) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_positive_i64 Check if a integer (64 bits) is positive. private subroutine assert_positive_i64 (this, i, fail) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_positive_r32 Check if a real (32 bits) is positive. private subroutine assert_positive_r32 (this, r, fail) Check if a real (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r Result to be checked. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_positive_r64 Check if a real (64 bits) is positive. private subroutine assert_positive_r64 (this, r, fail) Check if a real (64 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r Result to be checked. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_positive_i8_1 Check if a integer (8  bits) array (rank 1) is positive. private subroutine assert_positive_i8_1 (this, i, fail) Check if a integer (8 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in), dimension(:) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_positive_i16_1 Check if a integer (16 bits) array (rank 1) is positive. private subroutine assert_positive_i16_1 (this, i, fail) Check if a integer (16 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in), dimension(:) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_positive_i32_1 Check if a integer (32 bits) array (rank 1) is positive. private subroutine assert_positive_i32_1 (this, i, fail) Check if a integer (32 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in), dimension(:) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_positive_i64_1 Check if a integer (64 bits) array (rank 1) is positive. private subroutine assert_positive_i64_1 (this, i, fail) Check if a integer (64 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in), dimension(:) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_positive_r32_1 Check if a real (32 bits) array (rank 1) is positive. private subroutine assert_positive_r32_1 (this, r, fail) Check if a real (32 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r Result to be checked. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_positive_r64_1 Check if a real (64 bits) array (rank 1) is positive. private subroutine assert_positive_r64_1 (this, r, fail) Check if a real (64 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r Result to be checked. logical, intent(in), optional :: fail Fail flag. generic, public :: assert_close => assert_close_r32 , assert_close_r64 , assert_close_r32_1 , assert_close_r64_1 Check if two reals are close with respect a tolerance. private subroutine assert_close_r32 (this, r1, r2, fail) Check if two reals (32 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r1 Results to be compared. real(kind=real32), intent(in) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_close_r64 (this, r1, r2, fail) Check if two reals (64 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r1 Results to be compared. real(kind=real64), intent(in) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_close_r32_1 (this, r1, r2, fail) Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r1 Results to be compared. real(kind=real32), intent(in), dimension(:) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_close_r64_1 (this, r1, r2, fail) Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r1 Results to be compared. real(kind=real64), intent(in), dimension(:) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_close_r32 Check if two reals (32 bits) are close with respect a tolerance. private subroutine assert_close_r32 (this, r1, r2, fail) Check if two reals (32 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r1 Results to be compared. real(kind=real32), intent(in) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_close_r64 Check if two reals (64 bits) are close with respect a tolerance. private subroutine assert_close_r64 (this, r1, r2, fail) Check if two reals (64 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r1 Results to be compared. real(kind=real64), intent(in) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_close_r32_1 Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. private subroutine assert_close_r32_1 (this, r1, r2, fail) Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r1 Results to be compared. real(kind=real32), intent(in), dimension(:) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. procedure, private :: assert_close_r64_1 Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. private subroutine assert_close_r64_1 (this, r1, r2, fail) Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r1 Results to be compared. real(kind=real64), intent(in), dimension(:) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code type :: tester_t !< The main **tester** class. integer ( int32 ) :: n_errors = 0_int32 !< Number of errors. integer ( int32 ) :: n_tests = 0_int32 !< Number of tests. real ( real32 ) :: tolerance32 = 2._real32 * epsilon ( 1._real32 ) !< Real tolerance, 32 bits. real ( real64 ) :: tolerance64 = 2._real64 * epsilon ( 1._real64 ) !< Real tolerance, 64 bits. contains procedure :: init !< Initialize the tester. procedure :: print !< Print tests results. generic , public :: assert_equal => & assert_equal_i8 , & assert_equal_i16 , & assert_equal_i32 , & assert_equal_i64 , & assert_equal_r32 , & assert_equal_r64 , & assert_equal_l , & assert_equal_i8_1 , & assert_equal_i16_1 , & assert_equal_i32_1 , & assert_equal_i64_1 , & assert_equal_r32_1 , & assert_equal_r64_1 , & assert_equal_l_1 !< Check if two results (integer, real or logical) are equal. procedure , private :: assert_equal_i8 !< Check if two integers (8  bits) are equal. procedure , private :: assert_equal_i16 !< Check if two integers (16 bits) are equal. procedure , private :: assert_equal_i32 !< Check if two integers (32 bits) are equal. procedure , private :: assert_equal_i64 !< Check if two integers (64 bits) are equal. procedure , private :: assert_equal_r32 !< Check if two reals (32 bits) are equal. procedure , private :: assert_equal_r64 !< Check if two reals (64 bits) are equal. procedure , private :: assert_equal_l !< Check if two logicals are equal. procedure , private :: assert_equal_i8_1 !< Check if two integer (8  bits) arrays (rank 1) are equal. procedure , private :: assert_equal_i16_1 !< Check if two integer (16 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_i32_1 !< Check if two integer (32 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_i64_1 !< Check if two integer (64 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_r32_1 !< Check if two real (32 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_r64_1 !< Check if two real (64 bits) arrays (rank 1) are equal. procedure , private :: assert_equal_l_1 !< Check if two logical arrays (rank 1) are equal. generic , public :: assert_positive => & assert_positive_i8 , & assert_positive_i16 , & assert_positive_i32 , & assert_positive_i64 , & assert_positive_r32 , & assert_positive_r64 , & assert_positive_i8_1 , & assert_positive_i16_1 , & assert_positive_i32_1 , & assert_positive_i64_1 , & assert_positive_r32_1 , & assert_positive_r64_1 !< Check if a number (integer or real) is positive. procedure , private :: assert_positive_i8 !< Check if a integer (8  bits) is positive. procedure , private :: assert_positive_i16 !< Check if a integer (16 bits) is positive. procedure , private :: assert_positive_i32 !< Check if a integer (32 bits) is positive. procedure , private :: assert_positive_i64 !< Check if a integer (64 bits) is positive. procedure , private :: assert_positive_r32 !< Check if a real (32 bits) is positive. procedure , private :: assert_positive_r64 !< Check if a real (64 bits) is positive. procedure , private :: assert_positive_i8_1 !< Check if a integer (8  bits) array (rank 1) is positive. procedure , private :: assert_positive_i16_1 !< Check if a integer (16 bits) array (rank 1) is positive. procedure , private :: assert_positive_i32_1 !< Check if a integer (32 bits) array (rank 1) is positive. procedure , private :: assert_positive_i64_1 !< Check if a integer (64 bits) array (rank 1) is positive. procedure , private :: assert_positive_r32_1 !< Check if a real (32 bits) array (rank 1) is positive. procedure , private :: assert_positive_r64_1 !< Check if a real (64 bits) array (rank 1) is positive. generic , public :: assert_close => & assert_close_r32 , & assert_close_r64 , & assert_close_r32_1 , & assert_close_r64_1 !< Check if two reals are close with respect a tolerance. procedure , private :: assert_close_r32 !< Check if two reals (32 bits) are close with respect a tolerance. procedure , private :: assert_close_r64 !< Check if two reals (64 bits) are close with respect a tolerance. procedure , private :: assert_close_r32_1 !< Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. procedure , private :: assert_close_r64_1 !< Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. end type tester_t","tags":"","loc":"type/tester_t.html","title":"tester_t – fortran_tester "},{"text":"private subroutine init(this, tolerance32, tolerance64) Initialize the tester. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(out) :: this The tester. real(kind=real32), intent(in), optional :: tolerance32 Real tolerance, 32 bits. real(kind=real64), intent(in), optional :: tolerance64 Real tolerance, 64 bits. Source Code init Source Code subroutine init ( this , tolerance32 , tolerance64 ) !< Initialize the tester. class ( tester_t ), intent ( out ) :: this !< The tester. real ( real32 ), intent ( in ), optional :: tolerance32 !< Real tolerance, 32 bits. real ( real64 ), intent ( in ), optional :: tolerance64 !< Real tolerance, 64 bits. this % n_errors = 0 this % n_tests = 0 if ( present ( tolerance64 )) then this % tolerance64 = tolerance64 else this % tolerance64 = 2._real64 * epsilon ( 1._real64 ) end if if ( present ( tolerance32 )) then this % tolerance32 = tolerance32 else this % tolerance32 = 2._real32 * epsilon ( 1._real32 ) end if end subroutine init","tags":"","loc":"proc/init.html","title":"init – fortran_tester"},{"text":"private subroutine print(this, errorstop) Print tests results. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(in) :: this The tester. logical, intent(in), optional :: errorstop Flag to activate error stop if one test fails. Source Code print Source Code subroutine print ( this , errorstop ) !< Print tests results. class ( tester_t ), intent ( in ) :: this !< The tester. logical , intent ( in ), optional :: errorstop !< Flag to activate error stop if one test fails. logical :: do_errorstop if ( present ( errorstop )) then do_errorstop = errorstop else do_errorstop = . true . end if write ( * , * ) 'fortran_tester:' , this % n_errors , ' error(s) for' , this % n_tests , 'test(s)' if ( this % n_errors == 0 ) then write ( * , * ) 'fortran_tester: all tests succeeded' else if ( do_errorstop ) then error stop 'fortran_tester: tests failed' else write ( * , * ) 'fortran_tester: tests failed' end if end if end subroutine print","tags":"","loc":"proc/print.html","title":"print – fortran_tester"},{"text":"private subroutine assert_equal_i8(this, i1, i2, fail) Check if two integers (8 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in) :: i1 Results to be compared. integer(kind=int8), intent(in) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code assert_equal_i8 Source Code subroutine assert_equal_i8 ( this , i1 , i2 , fail ) !< Check if two integers (8 bits) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int8 ), intent ( in ) :: i1 , i2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( i1 . ne . i2 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_i8","tags":"","loc":"proc/assert_equal_i8.html","title":"assert_equal_i8 – fortran_tester"},{"text":"private subroutine assert_equal_i16(this, i1, i2, fail) Check if two integers (16 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in) :: i1 Results to be compared. integer(kind=int16), intent(in) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code assert_equal_i16 Source Code subroutine assert_equal_i16 ( this , i1 , i2 , fail ) !< Check if two integers (16 bits) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int16 ), intent ( in ) :: i1 , i2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( i1 . ne . i2 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_i16","tags":"","loc":"proc/assert_equal_i16.html","title":"assert_equal_i16 – fortran_tester"},{"text":"private subroutine assert_equal_i32(this, i1, i2, fail) Check if two integers (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in) :: i1 Results to be compared. integer(kind=int32), intent(in) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code assert_equal_i32 Source Code subroutine assert_equal_i32 ( this , i1 , i2 , fail ) !< Check if two integers (32 bits) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int32 ), intent ( in ) :: i1 , i2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( i1 . ne . i2 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_i32","tags":"","loc":"proc/assert_equal_i32.html","title":"assert_equal_i32 – fortran_tester"},{"text":"private subroutine assert_equal_i64(this, i1, i2, fail) Check if two integers (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in) :: i1 Results to be compared. integer(kind=int64), intent(in) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code assert_equal_i64 Source Code subroutine assert_equal_i64 ( this , i1 , i2 , fail ) !< Check if two integers (64 bits) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int64 ), intent ( in ) :: i1 , i2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( i1 . ne . i2 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_i64","tags":"","loc":"proc/assert_equal_i64.html","title":"assert_equal_i64 – fortran_tester"},{"text":"private subroutine assert_equal_r32(this, r1, r2, fail) Check if two reals (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r1 Results to be compared. real(kind=real32), intent(in) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code assert_equal_r32 Source Code subroutine assert_equal_r32 ( this , r1 , r2 , fail ) !< Check if two reals (32 bits) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), intent ( in ) :: r1 , r2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( r1 . ne . r2 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_r32","tags":"","loc":"proc/assert_equal_r32.html","title":"assert_equal_r32 – fortran_tester"},{"text":"private subroutine assert_equal_r64(this, r1, r2, fail) Check if two reals (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r1 Results to be compared. real(kind=real64), intent(in) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code assert_equal_r64 Source Code subroutine assert_equal_r64 ( this , r1 , r2 , fail ) !< Check if two reals (64 bits) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), intent ( in ) :: r1 , r2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( r1 . ne . r2 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_r64","tags":"","loc":"proc/assert_equal_r64.html","title":"assert_equal_r64 – fortran_tester"},{"text":"private subroutine assert_equal_l(this, l1, l2, fail) Check if two logicals are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. logical, intent(in) :: l1 Results to be compared. logical, intent(in) :: l2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code assert_equal_l Source Code subroutine assert_equal_l ( this , l1 , l2 , fail ) !< Check if two logicals are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. logical , intent ( in ) :: l1 , l2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( l1 . neqv . l2 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_equal_l","tags":"","loc":"proc/assert_equal_l.html","title":"assert_equal_l – fortran_tester"},{"text":"private subroutine assert_equal_i8_1(this, i1, i2, fail) Check if two integer (8 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in), dimension(:) :: i1 Results to be compared. integer(kind=int8), intent(in), dimension(:) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code assert_equal_i8_1 Source Code subroutine assert_equal_i8_1 ( this , i1 , i2 , fail ) !< Check if two integer (8 bits) arrays (rank 1) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int8 ), dimension (:), intent ( in ) :: i1 , i2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( size ( i1 ) . ne . size ( i2 ) ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if else if ( maxval ( abs ( i1 - i2 )) > 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end if end subroutine assert_equal_i8_1","tags":"","loc":"proc/assert_equal_i8_1.html","title":"assert_equal_i8_1 – fortran_tester"},{"text":"private subroutine assert_equal_i16_1(this, i1, i2, fail) Check if two integer (16 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in), dimension(:) :: i1 Results to be compared. integer(kind=int16), intent(in), dimension(:) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code assert_equal_i16_1 Source Code subroutine assert_equal_i16_1 ( this , i1 , i2 , fail ) !< Check if two integer (16 bits) arrays (rank 1) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int16 ), dimension (:), intent ( in ) :: i1 , i2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( size ( i1 ) . ne . size ( i2 ) ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if else if ( maxval ( abs ( i1 - i2 )) > 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end if end subroutine assert_equal_i16_1","tags":"","loc":"proc/assert_equal_i16_1.html","title":"assert_equal_i16_1 – fortran_tester"},{"text":"private subroutine assert_equal_i32_1(this, i1, i2, fail) Check if two integer (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in), dimension(:) :: i1 Results to be compared. integer(kind=int32), intent(in), dimension(:) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code assert_equal_i32_1 Source Code subroutine assert_equal_i32_1 ( this , i1 , i2 , fail ) !< Check if two integer (32 bits) arrays (rank 1) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int32 ), dimension (:), intent ( in ) :: i1 , i2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( size ( i1 ) . ne . size ( i2 ) ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if else if ( maxval ( abs ( i1 - i2 )) > 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end if end subroutine assert_equal_i32_1","tags":"","loc":"proc/assert_equal_i32_1.html","title":"assert_equal_i32_1 – fortran_tester"},{"text":"private subroutine assert_equal_i64_1(this, i1, i2, fail) Check if two integer (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in), dimension(:) :: i1 Results to be compared. integer(kind=int64), intent(in), dimension(:) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code assert_equal_i64_1 Source Code subroutine assert_equal_i64_1 ( this , i1 , i2 , fail ) !< Check if two integer (64 bits) arrays (rank 1) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int64 ), dimension (:), intent ( in ) :: i1 , i2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( size ( i1 ) . ne . size ( i2 ) ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if else if ( maxval ( abs ( i1 - i2 )) > 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end if end subroutine assert_equal_i64_1","tags":"","loc":"proc/assert_equal_i64_1.html","title":"assert_equal_i64_1 – fortran_tester"},{"text":"private subroutine assert_equal_r32_1(this, r1, r2, fail) Check if two real (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r1 Results to be compared. real(kind=real32), intent(in), dimension(:) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code assert_equal_r32_1 Source Code subroutine assert_equal_r32_1 ( this , r1 , r2 , fail ) !< Check if two real (32 bits) arrays (rank 1) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), dimension (:), intent ( in ) :: r1 , r2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( size ( r1 ) . ne . size ( r2 ) ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if else if ( maxval ( abs ( r1 - r2 )) > 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end if end subroutine assert_equal_r32_1","tags":"","loc":"proc/assert_equal_r32_1.html","title":"assert_equal_r32_1 – fortran_tester"},{"text":"private subroutine assert_equal_r64_1(this, r1, r2, fail) Check if two real (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r1 Results to be compared. real(kind=real64), intent(in), dimension(:) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code assert_equal_r64_1 Source Code subroutine assert_equal_r64_1 ( this , r1 , r2 , fail ) !< Check if two real (64 bits) arrays (rank 1) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), dimension (:), intent ( in ) :: r1 , r2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( size ( r1 ) . ne . size ( r2 ) ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if else if ( maxval ( abs ( r1 - r2 )) > 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end if end subroutine assert_equal_r64_1","tags":"","loc":"proc/assert_equal_r64_1.html","title":"assert_equal_r64_1 – fortran_tester"},{"text":"private subroutine assert_equal_l_1(this, l1, l2, fail) Check if two logical arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. logical, intent(in), dimension(:) :: l1 Results to be compared. logical, intent(in), dimension(:) :: l2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code assert_equal_l_1 Source Code subroutine assert_equal_l_1 ( this , l1 , l2 , fail ) !< Check if two logical arrays (rank 1) are equal. class ( tester_t ), intent ( inout ) :: this !< The tester. logical , intent ( in ), dimension (:) :: l1 , l2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. integer :: k this % n_tests = this % n_tests + 1 if ( size ( l1 ) . ne . size ( l2 ) ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if else do k = 1 , size ( l1 ) if ( l1 ( k ) . neqv . l2 ( k )) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if exit end if end do end if end subroutine assert_equal_l_1","tags":"","loc":"proc/assert_equal_l_1.html","title":"assert_equal_l_1 – fortran_tester"},{"text":"private subroutine assert_positive_i8(this, i, fail) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. Source Code assert_positive_i8 Source Code subroutine assert_positive_i8 ( this , i , fail ) !< Check if a integer (32 bits) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int8 ), intent ( in ) :: i !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( i < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_i8","tags":"","loc":"proc/assert_positive_i8.html","title":"assert_positive_i8 – fortran_tester"},{"text":"private subroutine assert_positive_i16(this, i, fail) Check if a integer (16 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. Source Code assert_positive_i16 Source Code subroutine assert_positive_i16 ( this , i , fail ) !< Check if a integer (16 bits) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int16 ), intent ( in ) :: i !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( i < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_i16","tags":"","loc":"proc/assert_positive_i16.html","title":"assert_positive_i16 – fortran_tester"},{"text":"private subroutine assert_positive_i32(this, i, fail) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. Source Code assert_positive_i32 Source Code subroutine assert_positive_i32 ( this , i , fail ) !< Check if a integer (32 bits) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int32 ), intent ( in ) :: i !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( i < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_i32","tags":"","loc":"proc/assert_positive_i32.html","title":"assert_positive_i32 – fortran_tester"},{"text":"private subroutine assert_positive_i64(this, i, fail) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. Source Code assert_positive_i64 Source Code subroutine assert_positive_i64 ( this , i , fail ) !< Check if a integer (32 bits) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int64 ), intent ( in ) :: i !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( i < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_i64","tags":"","loc":"proc/assert_positive_i64.html","title":"assert_positive_i64 – fortran_tester"},{"text":"private subroutine assert_positive_r32(this, r, fail) Check if a real (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r Result to be checked. logical, intent(in), optional :: fail Fail flag. Source Code assert_positive_r32 Source Code subroutine assert_positive_r32 ( this , r , fail ) !< Check if a real (32 bits) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), intent ( in ) :: r !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( r < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_r32","tags":"","loc":"proc/assert_positive_r32.html","title":"assert_positive_r32 – fortran_tester"},{"text":"private subroutine assert_positive_r64(this, r, fail) Check if a real (64 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r Result to be checked. logical, intent(in), optional :: fail Fail flag. Source Code assert_positive_r64 Source Code subroutine assert_positive_r64 ( this , r , fail ) !< Check if a real (64 bits) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), intent ( in ) :: r !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( r < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_r64","tags":"","loc":"proc/assert_positive_r64.html","title":"assert_positive_r64 – fortran_tester"},{"text":"private subroutine assert_positive_i8_1(this, i, fail) Check if a integer (8 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in), dimension(:) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. Source Code assert_positive_i8_1 Source Code subroutine assert_positive_i8_1 ( this , i , fail ) !< Check if a integer (8 bits) array (rank 1) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int8 ), dimension (:), intent ( in ) :: i !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( minval ( i ) < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_i8_1","tags":"","loc":"proc/assert_positive_i8_1.html","title":"assert_positive_i8_1 – fortran_tester"},{"text":"private subroutine assert_positive_i16_1(this, i, fail) Check if a integer (16 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in), dimension(:) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. Source Code assert_positive_i16_1 Source Code subroutine assert_positive_i16_1 ( this , i , fail ) !< Check if a integer (16 bits) array (rank 1) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int16 ), dimension (:), intent ( in ) :: i !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( minval ( i ) < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_i16_1","tags":"","loc":"proc/assert_positive_i16_1.html","title":"assert_positive_i16_1 – fortran_tester"},{"text":"private subroutine assert_positive_i32_1(this, i, fail) Check if a integer (32 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in), dimension(:) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. Source Code assert_positive_i32_1 Source Code subroutine assert_positive_i32_1 ( this , i , fail ) !< Check if a integer (32 bits) array (rank 1) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int32 ), dimension (:), intent ( in ) :: i !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( minval ( i ) < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_i32_1","tags":"","loc":"proc/assert_positive_i32_1.html","title":"assert_positive_i32_1 – fortran_tester"},{"text":"private subroutine assert_positive_i64_1(this, i, fail) Check if a integer (64 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in), dimension(:) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. Source Code assert_positive_i64_1 Source Code subroutine assert_positive_i64_1 ( this , i , fail ) !< Check if a integer (64 bits) array (rank 1) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. integer ( int64 ), dimension (:), intent ( in ) :: i !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( minval ( i ) < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_i64_1","tags":"","loc":"proc/assert_positive_i64_1.html","title":"assert_positive_i64_1 – fortran_tester"},{"text":"private subroutine assert_positive_r32_1(this, r, fail) Check if a real (32 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r Result to be checked. logical, intent(in), optional :: fail Fail flag. Source Code assert_positive_r32_1 Source Code subroutine assert_positive_r32_1 ( this , r , fail ) !< Check if a real (32 bits) array (rank 1) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), dimension (:), intent ( in ) :: r !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( minval ( r ) < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_r32_1","tags":"","loc":"proc/assert_positive_r32_1.html","title":"assert_positive_r32_1 – fortran_tester"},{"text":"private subroutine assert_positive_r64_1(this, r, fail) Check if a real (64 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r Result to be checked. logical, intent(in), optional :: fail Fail flag. Source Code assert_positive_r64_1 Source Code subroutine assert_positive_r64_1 ( this , r , fail ) !< Check if a real (64 bits) array (rank 1) is positive. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), dimension (:), intent ( in ) :: r !< Result to be checked. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( minval ( r ) < 0 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_positive_r64_1","tags":"","loc":"proc/assert_positive_r64_1.html","title":"assert_positive_r64_1 – fortran_tester"},{"text":"private subroutine assert_close_r32(this, r1, r2, fail) Check if two reals (32 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r1 Results to be compared. real(kind=real32), intent(in) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code assert_close_r32 Source Code subroutine assert_close_r32 ( this , r1 , r2 , fail ) !< Check if two reals (32 bits) are close with respect a tolerance. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), intent ( in ) :: r1 , r2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( abs ( r1 - r2 ) > this % tolerance32 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_close_r32","tags":"","loc":"proc/assert_close_r32.html","title":"assert_close_r32 – fortran_tester"},{"text":"private subroutine assert_close_r64(this, r1, r2, fail) Check if two reals (64 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r1 Results to be compared. real(kind=real64), intent(in) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code assert_close_r64 Source Code subroutine assert_close_r64 ( this , r1 , r2 , fail ) !< Check if two reals (64 bits) are close with respect a tolerance. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), intent ( in ) :: r1 , r2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( abs ( r1 - r2 ) > this % tolerance64 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end subroutine assert_close_r64","tags":"","loc":"proc/assert_close_r64.html","title":"assert_close_r64 – fortran_tester"},{"text":"private subroutine assert_close_r32_1(this, r1, r2, fail) Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r1 Results to be compared. real(kind=real32), intent(in), dimension(:) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code assert_close_r32_1 Source Code subroutine assert_close_r32_1 ( this , r1 , r2 , fail ) !< Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real32 ), intent ( in ), dimension (:) :: r1 , r2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( size ( r1 ) . ne . size ( r2 ) ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if else if ( maxval ( abs ( r1 - r2 )) > this % tolerance64 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end if end subroutine assert_close_r32_1","tags":"","loc":"proc/assert_close_r32_1.html","title":"assert_close_r32_1 – fortran_tester"},{"text":"private subroutine assert_close_r64_1(this, r1, r2, fail) Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r1 Results to be compared. real(kind=real64), intent(in), dimension(:) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. Source Code assert_close_r64_1 Source Code subroutine assert_close_r64_1 ( this , r1 , r2 , fail ) !< Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. class ( tester_t ), intent ( inout ) :: this !< The tester. real ( real64 ), intent ( in ), dimension (:) :: r1 , r2 !< Results to be compared. logical , intent ( in ), optional :: fail !< Fail flag. this % n_tests = this % n_tests + 1 if ( size ( r1 ) . ne . size ( r2 ) ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if else if ( maxval ( abs ( r1 - r2 )) > this % tolerance64 ) then if (. not . present ( fail ) . or . ( present ( fail ) . and . fail . eqv . . false .)) then this % n_errors = this % n_errors + 1 end if end if end if end subroutine assert_close_r64_1","tags":"","loc":"proc/assert_close_r64_1.html","title":"assert_close_r64_1 – fortran_tester"},{"text":"Uses: iso_fortran_env module~~tester~~UsesGraph module~tester tester iso_fortran_env iso_fortran_env iso_fortran_env->module~tester Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Used By module~~tester~~UsedByGraph module~tester tester program~test_mt test_mt module~tester->program~test_mt program~test_mt~4 test_mt module~tester->program~test_mt~4 program~test_mt~2 test_mt module~tester->program~test_mt~2 program~test_mt~3 test_mt module~tester->program~test_mt~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types tester_t Subroutines init print assert_equal_i8 assert_equal_i16 assert_equal_i32 assert_equal_i64 assert_equal_r32 assert_equal_r64 assert_equal_l assert_equal_i8_1 assert_equal_i16_1 assert_equal_i32_1 assert_equal_i64_1 assert_equal_r32_1 assert_equal_r64_1 assert_equal_l_1 assert_positive_i8 assert_positive_i16 assert_positive_i32 assert_positive_i64 assert_positive_r32 assert_positive_r64 assert_positive_i8_1 assert_positive_i16_1 assert_positive_i32_1 assert_positive_i64_1 assert_positive_r32_1 assert_positive_r64_1 assert_close_r32 assert_close_r64 assert_close_r32_1 assert_close_r64_1 Derived Types type, public :: tester_t The main tester class. Components Type Visibility Attributes Name Initial integer(kind=int32), public :: n_errors = 0_int32 Number of errors. integer(kind=int32), public :: n_tests = 0_int32 Number of tests. real(kind=real32), public :: tolerance32 = 2._real32*epsilon(1._real32) Real tolerance, 32 bits. real(kind=real64), public :: tolerance64 = 2._real64*epsilon(1._real64) Real tolerance, 64 bits. Type-Bound Procedures procedure, public :: init Initialize the tester. procedure, public :: print Print tests results. generic, public :: assert_equal => assert_equal_i8, assert_equal_i16, assert_equal_i32, assert_equal_i64, assert_equal_r32, assert_equal_r64, assert_equal_l, assert_equal_i8_1, assert_equal_i16_1, assert_equal_i32_1, assert_equal_i64_1, assert_equal_r32_1, assert_equal_r64_1, assert_equal_l_1 Check if two results (integer, real or logical) are equal. procedure, private :: assert_equal_i8 Check if two integers (8  bits) are equal. procedure, private :: assert_equal_i16 Check if two integers (16 bits) are equal. procedure, private :: assert_equal_i32 Check if two integers (32 bits) are equal. procedure, private :: assert_equal_i64 Check if two integers (64 bits) are equal. procedure, private :: assert_equal_r32 Check if two reals (32 bits) are equal. procedure, private :: assert_equal_r64 Check if two reals (64 bits) are equal. procedure, private :: assert_equal_l Check if two logicals are equal. procedure, private :: assert_equal_i8_1 Check if two integer (8  bits) arrays (rank 1) are equal. procedure, private :: assert_equal_i16_1 Check if two integer (16 bits) arrays (rank 1) are equal. procedure, private :: assert_equal_i32_1 Check if two integer (32 bits) arrays (rank 1) are equal. procedure, private :: assert_equal_i64_1 Check if two integer (64 bits) arrays (rank 1) are equal. procedure, private :: assert_equal_r32_1 Check if two real (32 bits) arrays (rank 1) are equal. procedure, private :: assert_equal_r64_1 Check if two real (64 bits) arrays (rank 1) are equal. procedure, private :: assert_equal_l_1 Check if two logical arrays (rank 1) are equal. generic, public :: assert_positive => assert_positive_i8, assert_positive_i16, assert_positive_i32, assert_positive_i64, assert_positive_r32, assert_positive_r64, assert_positive_i8_1, assert_positive_i16_1, assert_positive_i32_1, assert_positive_i64_1, assert_positive_r32_1, assert_positive_r64_1 Check if a number (integer or real) is positive. procedure, private :: assert_positive_i8 Check if a integer (8  bits) is positive. procedure, private :: assert_positive_i16 Check if a integer (16 bits) is positive. procedure, private :: assert_positive_i32 Check if a integer (32 bits) is positive. procedure, private :: assert_positive_i64 Check if a integer (64 bits) is positive. procedure, private :: assert_positive_r32 Check if a real (32 bits) is positive. procedure, private :: assert_positive_r64 Check if a real (64 bits) is positive. procedure, private :: assert_positive_i8_1 Check if a integer (8  bits) array (rank 1) is positive. procedure, private :: assert_positive_i16_1 Check if a integer (16 bits) array (rank 1) is positive. procedure, private :: assert_positive_i32_1 Check if a integer (32 bits) array (rank 1) is positive. procedure, private :: assert_positive_i64_1 Check if a integer (64 bits) array (rank 1) is positive. procedure, private :: assert_positive_r32_1 Check if a real (32 bits) array (rank 1) is positive. procedure, private :: assert_positive_r64_1 Check if a real (64 bits) array (rank 1) is positive. generic, public :: assert_close => assert_close_r32, assert_close_r64, assert_close_r32_1, assert_close_r64_1 Check if two reals are close with respect a tolerance. procedure, private :: assert_close_r32 Check if two reals (32 bits) are close with respect a tolerance. procedure, private :: assert_close_r64 Check if two reals (64 bits) are close with respect a tolerance. procedure, private :: assert_close_r32_1 Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. procedure, private :: assert_close_r64_1 Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. Subroutines private subroutine init (this, tolerance32, tolerance64) Initialize the tester. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(out) :: this The tester. real(kind=real32), intent(in), optional :: tolerance32 Real tolerance, 32 bits. real(kind=real64), intent(in), optional :: tolerance64 Real tolerance, 64 bits. private subroutine print (this, errorstop) Print tests results. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(in) :: this The tester. logical, intent(in), optional :: errorstop Flag to activate error stop if one test fails. private subroutine assert_equal_i8 (this, i1, i2, fail) Check if two integers (8 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in) :: i1 Results to be compared. integer(kind=int8), intent(in) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_i16 (this, i1, i2, fail) Check if two integers (16 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in) :: i1 Results to be compared. integer(kind=int16), intent(in) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_i32 (this, i1, i2, fail) Check if two integers (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in) :: i1 Results to be compared. integer(kind=int32), intent(in) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_i64 (this, i1, i2, fail) Check if two integers (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in) :: i1 Results to be compared. integer(kind=int64), intent(in) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_r32 (this, r1, r2, fail) Check if two reals (32 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r1 Results to be compared. real(kind=real32), intent(in) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_r64 (this, r1, r2, fail) Check if two reals (64 bits) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r1 Results to be compared. real(kind=real64), intent(in) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_l (this, l1, l2, fail) Check if two logicals are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. logical, intent(in) :: l1 Results to be compared. logical, intent(in) :: l2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_i8_1 (this, i1, i2, fail) Check if two integer (8 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in), dimension(:) :: i1 Results to be compared. integer(kind=int8), intent(in), dimension(:) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_i16_1 (this, i1, i2, fail) Check if two integer (16 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in), dimension(:) :: i1 Results to be compared. integer(kind=int16), intent(in), dimension(:) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_i32_1 (this, i1, i2, fail) Check if two integer (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in), dimension(:) :: i1 Results to be compared. integer(kind=int32), intent(in), dimension(:) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_i64_1 (this, i1, i2, fail) Check if two integer (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in), dimension(:) :: i1 Results to be compared. integer(kind=int64), intent(in), dimension(:) :: i2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_r32_1 (this, r1, r2, fail) Check if two real (32 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r1 Results to be compared. real(kind=real32), intent(in), dimension(:) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_r64_1 (this, r1, r2, fail) Check if two real (64 bits) arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r1 Results to be compared. real(kind=real64), intent(in), dimension(:) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_equal_l_1 (this, l1, l2, fail) Check if two logical arrays (rank 1) are equal. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. logical, intent(in), dimension(:) :: l1 Results to be compared. logical, intent(in), dimension(:) :: l2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_i8 (this, i, fail) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_i16 (this, i, fail) Check if a integer (16 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_i32 (this, i, fail) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_i64 (this, i, fail) Check if a integer (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_r32 (this, r, fail) Check if a real (32 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_r64 (this, r, fail) Check if a real (64 bits) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_i8_1 (this, i, fail) Check if a integer (8 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int8), intent(in), dimension(:) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_i16_1 (this, i, fail) Check if a integer (16 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int16), intent(in), dimension(:) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_i32_1 (this, i, fail) Check if a integer (32 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int32), intent(in), dimension(:) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_i64_1 (this, i, fail) Check if a integer (64 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. integer(kind=int64), intent(in), dimension(:) :: i Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_r32_1 (this, r, fail) Check if a real (32 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_positive_r64_1 (this, r, fail) Check if a real (64 bits) array (rank 1) is positive. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r Result to be checked. logical, intent(in), optional :: fail Fail flag. private subroutine assert_close_r32 (this, r1, r2, fail) Check if two reals (32 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in) :: r1 Results to be compared. real(kind=real32), intent(in) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_close_r64 (this, r1, r2, fail) Check if two reals (64 bits) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in) :: r1 Results to be compared. real(kind=real64), intent(in) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_close_r32_1 (this, r1, r2, fail) Check if two real (32 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real32), intent(in), dimension(:) :: r1 Results to be compared. real(kind=real32), intent(in), dimension(:) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag. private subroutine assert_close_r64_1 (this, r1, r2, fail) Check if two real (64 bits) arrays (rank 1) are close with respect a tolerance. Arguments Type Intent Optional Attributes Name class( tester_t ), intent(inout) :: this The tester. real(kind=real64), intent(in), dimension(:) :: r1 Results to be compared. real(kind=real64), intent(in), dimension(:) :: r2 Results to be compared. logical, intent(in), optional :: fail Fail flag.","tags":"","loc":"module/tester.html","title":"tester – fortran_tester"},{"text":"Uses: tester program~~test_mt~~UsesGraph program~test_mt test_mt module~tester tester module~tester->program~test_mt iso_fortran_env iso_fortran_env iso_fortran_env->module~tester Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Calls program~~test_mt~~CallsGraph program~test_mt test_mt init init program~test_mt->init assert_equal assert_equal program~test_mt->assert_equal assert_close assert_close program~test_mt->assert_close Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables test Source Code test_mt Variables Type Attributes Name Initial type( tester_t ) :: test Source Code program test_mt use tester implicit none type ( tester_t ) :: test call test % init () call test % assert_equal ( 1 , 2 , fail = . true .) call test % assert_equal ( - 121 , - 11 ** 2 ) call test % assert_equal ([ 1 , - 10 , 1899010 ], [ 1 , - 10 , 1899010 ]) call test % assert_equal (. true ., 2 > 1 ) call test % assert_close ( 1. d0 , ( 1. d0 + 1. d - 16 )) call test % assert_close ( 1. d0 , ( 1. d0 + 1. d - 15 ), fail = . true .) call test % assert_close ( 1. , ( 1. + 1.e-7 )) call test % assert_close ( 1. , ( 1. + 1.e-6 ), fail = . true .) call test % assert_close ([ 1. d0 , 2. d0 , 3. d0 ], [ 1. d0 + 1. d - 15 , 2. d0 , 3. d0 ], fail = . true .) call test % assert_close ([ 1. d0 , 2. d0 ], [ 1. d0 , 2. d0 , 3. d0 ], fail = . true .) call test % assert_close ([ 1. d0 , 2. d0 ], [ 1. d0 , 2. d0 ]) call test % print () end program test_mt","tags":"","loc":"program/test_mt.html","title":"test_mt – fortran_tester"},{"text":"Uses: tester program~~test_mt~2~~UsesGraph program~test_mt~2 test_mt module~tester tester module~tester->program~test_mt~2 iso_fortran_env iso_fortran_env iso_fortran_env->module~tester Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables test Source Code test_mt Variables Type Attributes Name Initial type( tester_t ) :: test Source Code program test_mt use tester implicit none type ( tester_t ) :: test call test % init () call test % assert_equal ( 1 , 2 ) call test % print () end program test_mt","tags":"","loc":"program/test_mt~2.html","title":"test_mt – fortran_tester"},{"text":"Uses: tester program~~test_mt~3~~UsesGraph program~test_mt~3 test_mt module~tester tester module~tester->program~test_mt~3 iso_fortran_env iso_fortran_env iso_fortran_env->module~tester Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables test Source Code test_mt Variables Type Attributes Name Initial type( tester_t ) :: test Source Code program test_mt use tester implicit none type ( tester_t ) :: test call test % init () call test % assert_equal ([. false ., . true .], [ 1 > 2 , 2 > 1 ]) call test % print () end program test_mt","tags":"","loc":"program/test_mt~3.html","title":"test_mt – fortran_tester"},{"text":"Uses: tester program~~test_mt~4~~UsesGraph program~test_mt~4 test_mt module~tester tester module~tester->program~test_mt~4 iso_fortran_env iso_fortran_env iso_fortran_env->module~tester Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables test Source Code test_mt Variables Type Attributes Name Initial type( tester_t ) :: test Source Code program test_mt use tester implicit none type ( tester_t ) :: test call test % init () call test % assert_equal (. true ., 1 > 2 ) call test % print () end program test_mt","tags":"","loc":"program/test_mt~4.html","title":"test_mt – fortran_tester"}]}